# LXC Manager Project Rules

## File Locations

- Shared templates: `json/shared/templates/`
- Application templates: `json/applications/`
- Scripts: in the corresponding `scripts/` subdirectory of each template
- Schemas: `schemas/`
- Examples: `local/` (root level) and `backend/local/` (backend-specific examples)

## Templates

- Templates in `json/shared/templates/` and `json/applications/` must be validated against `schemas/template.schema.json`
- Template outputs must conform to `schemas/output.template.schema.json` (only `id` and optional `default` allowed)
- Scripts referenced in templates must exist in the corresponding `scripts/` directory

## Applications

- Application templates must conform to `schemas/application.schema.json`
- Applications can use inheritance via `extends` to reuse other applications

## Parameters

- Parameters are passed between templates by matching parameter names (name equality)
- Parameters are automatically discovered across templates; no need to initialize them in the first template
- Best practice: Create a `set-parameters.json` template for each application to define application-specific defaults (e.g., `ostype`)
- if outputs is in the form  { "id": "<some id>", "default": "<some value>"}, this parameter is considered as default.
- if outputs is in the form  { "id": "<some id>", "default": "<some value>"}, this parameter is considered as default.

- Child applications (via `extends`) can override `set-parameters.json` to customize inherited behavior


## Schemas

- All JSON schemas are in `schemas/`
- Use JSON Schema draft-07

## Shell Scripts

- Scripts run inside Alpine Linux LXC containers
- Use POSIX-compliant `/bin/sh`, not bash
- Template variables use `{{ variable }}` syntax
- stdout must only contain JSON output valid against `schemas/outputs.schema.json`
- All other output (logs, debug, errors) must go to stderr
- Never use `2>&1` in scripts under `json/**/scripts/` as it redirects stderr to stdout, violating the JSON-only stdout rule


## Language
- All files must use English for file content, variable names, keys, strings, and outputs. Descriptions, comments, and documentation inside files must also be in English.
- German may only be used in user-facing chat, or in translation resources specifically intended for UI localization.


