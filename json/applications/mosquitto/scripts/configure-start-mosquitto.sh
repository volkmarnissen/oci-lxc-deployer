#!/bin/sh
# Configure Mosquitto MQTT broker (runs inside the container)
# Inputs (templated):
#   {{ auth_mode }}    - Authentication mode: none, password, or certificate
#   {{ mqtt_port }}    - Port number for MQTT
#   {{ mqtts_port }}   - Port number for MQTT over TLS
#   {{ mqtt_username }}     - Username for password authentication
#   {{ mqtt_password }}     - Password for password authentication
#   {{ bind_address }} - IP address to bind to
#   {{ server_cert }}  - Base64-encoded server certificate content
#   {{ server_key }}   - Base64-encoded server private key content
#   {{ ca_cert }}      - Base64-encoded CA certificate content (optional, for client cert auth)
set -eu

# Global variables
AUTH_MODE="{{ auth_mode }}"
MQTT_PORT="{{ mqtt_port }}"
MQTTS_PORT="{{ mqtts_port }}"
USERNAME="{{ mqtt_username }}"
PASSWORD="{{ mqtt_password }}"
BIND_ADDRESS="{{ bind_address }}"
SERVER_CERT="{{ server_cert }}"
SERVER_KEY="{{ server_key }}"
CA_CERT="{{ ca_cert }}"

MOSQUITTO_CONF="/etc/mosquitto/mosquitto.conf"
PASSWORD_FILE="/etc/mosquitto/passwd"
CERTS_DIR="/etc/mosquitto/certs"

# Create base configuration file
create_base_config() {
  cat > "$MOSQUITTO_CONF" << 'EOF'
# Mosquitto MQTT Broker Configuration
# Generated by oci-lxc-deployer

# General settings
pid_file /var/lib/mosquitto/mosquitto.pid
user mosquitto

# Persistence
persistence true
persistence_location /var/lib/mosquitto/

# Logging
log_dest file /var/log/mosquitto/mosquitto.log
log_type all
log_timestamp true

# Connection settings
max_connections -1
max_inflight_messages 20
max_queued_messages 1000

# Message settings
message_size_limit 0
retained_persistence true
autosave_interval 300
EOF
}

# Setup required directories
setup_directories() {
  # Configuration directory
  mkdir -p /etc/mosquitto >&2
  chown -R mosquitto:mosquitto /etc/mosquitto >&2

  # Log directory
  mkdir -p /var/log/mosquitto >&2
  chown mosquitto:mosquitto /var/log/mosquitto >&2

  # Data directory
  mkdir -p /var/lib/mosquitto >&2
  chown mosquitto:mosquitto /var/lib/mosquitto >&2

  # Run directory for PID file (important for unprivileged containers)
  if [ ! -d "/run" ]; then
    mkdir -p /run >&2
  fi
  chmod 755 /run >&2 || true

  # Try to create subdirectory for mosquitto if possible
  if [ -d "/run" ]; then
    mkdir -p /run/mosquitto >&2 || true
    if [ -d "/run/mosquitto" ]; then
      chown mosquitto:mosquitto /run/mosquitto >&2 || true
      chmod 755 /run/mosquitto >&2 || true
    fi
  fi
}

# Configure authentication: none
configure_auth_none() {
  cat >> "$MOSQUITTO_CONF" << EOF

# Listener on MQTT port (no authentication)
listener ${MQTT_PORT} ${BIND_ADDRESS}
allow_anonymous true
EOF
  echo "Configured Mosquitto with no authentication on port ${MQTT_PORT}" >&2
}

# Configure authentication: password
configure_auth_password() {
  # Validate credentials
  if [ -z "$USERNAME" ] || [ -z "$PASSWORD" ] || [ "$USERNAME" = "NOT_DEFINED" ] || [ "$PASSWORD" = "NOT_DEFINED" ]; then
    echo "Error: Username and password are required for password authentication mode" >&2
    exit 1
  fi

  # Create password file
  if [ -f "$PASSWORD_FILE" ]; then
    rm -f "$PASSWORD_FILE" >&2
  fi

  # Create password file with username/password
  # mosquitto_passwd -b means password is provided as argument (not from stdin)
  mosquitto_passwd -c -b "$PASSWORD_FILE" "$USERNAME" "$PASSWORD" >&2

  # Set proper permissions
  chown mosquitto:mosquitto "$PASSWORD_FILE" >&2
  chmod 600 "$PASSWORD_FILE" >&2

  cat >> "$MOSQUITTO_CONF" << EOF

# Listener on MQTT port (password authentication)
listener ${MQTT_PORT} ${BIND_ADDRESS}
allow_anonymous false
password_file ${PASSWORD_FILE}
EOF
  echo "Configured Mosquitto with password authentication on port ${MQTT_PORT}" >&2
}

# Setup certificates directory
setup_certs_directory() {
  mkdir -p "$CERTS_DIR" >&2
  chown mosquitto:mosquitto "$CERTS_DIR" >&2
  chmod 700 "$CERTS_DIR" >&2
}

# Handle CA certificate (optional, only for client cert auth)
handle_ca_certificate() {
  if [ -n "$CA_CERT" ] && [ "$CA_CERT" != "NOT_DEFINED" ]; then
    echo "Using uploaded CA certificate for client authentication" >&2
    echo "$CA_CERT" | base64 -d > "$CERTS_DIR/ca.crt" >&2
    chown mosquitto:mosquitto "$CERTS_DIR/ca.crt" >&2
    chmod 644 "$CERTS_DIR/ca.crt" >&2
    return 0  # CA exists
  fi
  return 1  # No CA
}

# Generate self-signed server certificate
generate_self_signed_server_cert() {
  echo "Generating self-signed server certificate..." >&2
  openssl req -x509 -newkey rsa:2048 -keyout "$CERTS_DIR/server.key" \
    -out "$CERTS_DIR/server.crt" -days 3650 -nodes \
    -subj "/CN=MQTT Server" >&2
  chown mosquitto:mosquitto "$CERTS_DIR/server.key" "$CERTS_DIR/server.crt" >&2
  chmod 600 "$CERTS_DIR/server.key" >&2
  chmod 644 "$CERTS_DIR/server.crt" >&2
}

# Handle server certificate - use uploaded or generate self-signed
handle_server_certificate() {
  if [ -n "$SERVER_CERT" ] && [ "$SERVER_CERT" != "NOT_DEFINED" ]; then
    echo "Using uploaded server certificate" >&2
    echo "$SERVER_CERT" | base64 -d > "$CERTS_DIR/server.crt" >&2
    if [ -n "$SERVER_KEY" ] && [ "$SERVER_KEY" != "NOT_DEFINED" ]; then
      echo "$SERVER_KEY" | base64 -d > "$CERTS_DIR/server.key" >&2
    else
      echo "Error: Server certificate provided but server key is missing" >&2
      exit 1
    fi
    chown mosquitto:mosquitto "$CERTS_DIR/server.crt" "$CERTS_DIR/server.key" >&2
    chmod 644 "$CERTS_DIR/server.crt" >&2
    chmod 600 "$CERTS_DIR/server.key" >&2
  else
    # Generate self-signed server certificate (CA_KEY not available for signing)
    generate_self_signed_server_cert
    echo "Server certificate generated at ${CERTS_DIR}/server.crt" >&2
  fi
}

# Configure authentication: certificate
configure_auth_certificate() {
  setup_certs_directory

  # Handle CA certificate (optional)
  HAS_CA=false
  if handle_ca_certificate; then
    HAS_CA=true
  fi

  # Handle server certificate
  handle_server_certificate

  # Configure TLS listener
  cat >> "$MOSQUITTO_CONF" << EOF

# Listener on MQTTS port (TLS)
listener ${MQTTS_PORT} ${BIND_ADDRESS}
protocol mqtt
certfile ${CERTS_DIR}/server.crt
keyfile ${CERTS_DIR}/server.key
EOF

  # Add CA and client certificate requirements only if CA is provided
  if [ "$HAS_CA" = "true" ]; then
    cat >> "$MOSQUITTO_CONF" << EOF
cafile ${CERTS_DIR}/ca.crt
require_certificate true
use_identity_as_username true
allow_anonymous false
EOF
    echo "Configured Mosquitto with TLS and client certificate authentication on port ${MQTTS_PORT}" >&2
  else
    cat >> "$MOSQUITTO_CONF" << EOF
allow_anonymous true
EOF
    echo "Configured Mosquitto with TLS (no client certificate required) on port ${MQTTS_PORT}" >&2
  fi
}

# Restart mosquitto service
restart_mosquitto_service() {
  if command -v rc-service >/dev/null 2>&1; then
    # Alpine Linux with OpenRC
    echo "Restarting mosquitto service..." >&2
    rc-service mosquitto restart >&2 || {
      echo "Warning: Failed to restart mosquitto service. Service may need manual restart." >&2
    }
  elif command -v systemctl >/dev/null 2>&1; then
    # Debian/Ubuntu with systemd
    echo "Restarting mosquitto service..." >&2
    systemctl restart mosquitto >&2 || {
      echo "Warning: Failed to restart mosquitto service. Service may need manual restart." >&2
    }
  else
    echo "Warning: No supported service manager found. Mosquitto service may need manual restart." >&2
  fi
}

# Main execution
main() {
  setup_directories
  create_base_config

  # Configure authentication based on mode
  case "$AUTH_MODE" in
    none)
      configure_auth_none
      ;;
    password)
      configure_auth_password
      ;;
    certificate)
      configure_auth_certificate
      ;;
    *)
      echo "Error: Invalid authentication mode: ${AUTH_MODE}" >&2
      echo "Valid modes are: none, password, certificate" >&2
      exit 1
      ;;
  esac

  echo "Mosquitto configuration completed successfully" >&2
  restart_mosquitto_service
}

# Run main function
main

exit 0
